##  Tower Defense



##  Project Overview

A Tower Defense (TD) Game is a strategic game where players place defensive structures (towers) along a path to stop waves of enemies from reaching a specific point.

link: 

## Project Review

Like Kingdom Rush, maybe a different theme like space theme with different tower and unit design.


##  Programming Development

###  3.1 Game Concept
The objective is to survive enemy waves by deploying turrets. Each turret automatically attacks enemies within its range. Players earn gold from defeating enemies, which they use to build or upgrade turrets. Strategy revolves around placement, upgrades, and resource management.

### 3.2  Object-Oriented Programming Implementation
- main.py
Controls overall game state. It initializes and holds game components (player, enemies, loot drops, projectiles, UI elements like the shop and skill tree, and the database), manages the game loop (updating and drawing game elements, handling spawning, collisions, and levels), and signals game over.
- Database
Collects and records game statistics at regular intervals (now every 10 seconds). It tracks metrics such as damage taken, net coins collected, zombies killed, the number of player attacks (e.g., left mouse clicks), and the types of zombies killed. It then saves these statistics to a CSV file for later analysis by your visualization UI.
- Player
Represents the user’s character. It handles movement, health, experience, and special abilities (like the earthquake). It also tracks an attack_count (incremented when the player left-clicks) and contains a Weapon instance to manage combat.
- Weapon
Is associated with the Player and defines the player’s attack mechanics. It handles the swinging action, collision detection with enemies, applying damage to zombies, and triggering related effects (e.g., registering the type of zombie killed).
- LootDrops
Manages the spawning and drawing of loot items (such as health boxes) dropped by defeated enemies. It checks when the player collects these items and applies effects (such as restoring health).
- Shop
Provides a user interface for purchasing upgrades or items during gameplay. It interacts with the Game instance to change game parameters based on player choices. (Its implementation serves as part of your UI interactions.)
- SkillTree
Is the in-game UI that lets the player upgrade skills or abilities. Like Shop, it interacts with the Game to apply upgrades but focuses on a different set of enhancements for the player.
- Zombie (and its subclasses: SpeedyZombie, TankyZombie, SpitterZombie, KingZombie)
Models enemy behavior. The base Zombie class defines fundamental properties and functions (like moving toward the player and drawing itself). Each subclass specializes in attributes such as speed, health, or attack method, making for varied enemy behavior.
- Projectile
Represents any bullet or other projectile in the game. It updates its position and checks for collisions (e.g., against the player or boundaries), contributing to the dynamics of combat when used by the player or enemies.
- CustomStatsApp (from data_show.py)
Implements a Tkinter-based graphical user interface that reads the CSV file generated by the Database class and visualizes the collected game statistics using Pandas, Seaborn, and Matplotlib. This UI lets you explore graphs (boxplots, scatter plots, bar plots, etc.) reflecting player and enemy data over time.
Each of these classes works together to form your game’s system—from managing gameplay and collecting data to visualizing statistics.

![alt text](images/image.png)



###  3.3 Algorithms Involved
1.Pathfinding/Movement Algorithm: Zombies use a simple vector-based technique to calculate the direction and move incrementally towards the player's position.
2.Random Spawning: The game uses a randomized interval combined with weighted probabilities to spawn different types of zombies, ensuring varied enemy encounters.
Collision Detection: Pygame’s rectangle collision functions for both combat weapon hit detection and pickups loot collection.

## Statistical Data (Prop Stats)
### 4.1 Data Features

1. total damage player taken evry 10 sec: line graph

2.total coin player collect with in 10sec: bar graph

3.total zombie killed every within 10 sec: scatter plot

4.player attack count with in 10sec: boxplot

5.types of zombie killed: table




### 3.2 Data Recording Method
- Tracking Data:
The game uses the Database class to track several metrics during gameplay—such as the damage taken by the player, net coins collected, the number of zombies killed, how many times the player attacked (left-clicked), and the types of zombies killed. These metrics are stored in corresponding lists (e.g., damage_taken, coin_collect, zombie_killed, player_attack_count, and zombie_type).
- Periodic Sampling:
Every 10 seconds, the Database.update() method is called during the game loop. This method computes the difference between the current game state (like the current coin count or number of zombie kills) and the values recorded in the previous interval. For example, if the coin count increased, that increase is logged; if not (or if negative), a zero is recorded. The same is done for player attacks (by comparing the current attack_count with the value from the last update).
- Appending Data:
Once these differences (or new values) are computed, they are appended to the respective lists. Meanwhile, the types of zombies killed are recorded immediately via the register_zombie_kill() method.
